---
title: "Extensions to ggplot - Additional Plots"
author: "Peter Higgins"
date: "10/21/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(medicaldata)
library(webexercises)
library(waffle)
library(ggalluvial)
library(ggrepel)
library(ggforce)
library(ggalt)
library(ggtext)
library(ggsignif)
library(ggbump)
library(survminer)
library(ggmosaic)
library(ggcorrplot)
library(plotROC)
library(directlabels)
library(geomtextpath)
library(ggheatmap)
library(ggQC)
library(ggupset)
library(ComplexUpset)
library(plotly)
library(gganimate)

indo_rct <- medicaldata::indo_rct
```

# Extensions to ggplot

The {ggplot2} package is made to be _extensible_ - so that other people can write packages that add new (often niche) geoms for specific purposes. This chapter is a short tour of some of the neat extensions people have written, and when and where they can be useful. Please check out the links to the individual packages to learn more, as we will frequently just scratch the surface of what is available.

## Goals for this Chapter
 - learn how and why to use waffle plots
 - learn how and when to use alluvial plots
 - learn how and when to use lollipop plots
 - learn how and when to use dumbbell plots
 - learn how and when to use spaghetti plots
  
## Packages Needed for this chapter

You will need {tidyverse}, {medicaldata}, {waffle}, {ggalluvial}, {ggalt}, {ggrepel}, {ggforce}, {ggalt}, {ggtext}. {ggsignif}, {ggbump}, {survminer}, {ggcorrplot}, {plotROC}, {directlabels}, {geomtextpath}, {ggheatmap}, {ggQC}, {ggupset}, {plotly}, and {gganimate}.


```{r}
# install.packages('tidyverse')
# install.packages('medicaldata')
library(tidyverse)
library(medicaldata)
library(ggrepel)
library(ggforce)
library(ggalt)
library(ggtext)
library(ggsignif)
library(ggbump)
library(survminer)
library(ggmosaic)
library(ggcorrplot)
library(plotROC)
library(directlabels)
library(geomtextpath)
library(ggheatmap)
library(ggQC)
library(ggupset)
library(ComplexUpset)
library(plotly)
library(gganimate)

```

## A Flipbook of Where We Are Going With ggplot Extensions

See the flipbook below, which contains some examples of what you can do with ggplot extensions. 

You can use the the icons in the bottom bar to expand to full screen or share this flipbook. If you are in full screen mode, you can use the Home button to go the the first slide and the End button to go to the last slide, and the Escape key to get out of full screen mode.

### MAKE FLIPBOOK

<!---FLIPBOOK EX 1--> 

<iframe style="margin:0 auto; border: solid black;" 
id="myIframe11" width="763" height="432"
src="https://higgi13425.github.io/mini_flipbooks/scales_microflip.html#1" 
scrolling="no" data-external="1" 
allowfullscreen
loading="lazy">
</iframe>

<!-------------> 

## A Waffle Plot

Why is this better than a bar plot or a dotplot?

In order to represent counts, or individual participants in a trial, a bar plot is a bit deceiving. It appears to be a continuous variable. But each participant in a clinical trial is a discrete individual. A bar plot can be helpful for very large numbers, but for manageable numbers it is a bit of a misrepresentation.

A dotplot, with geom_dotplot, would seem like a good option, but it only displays proportions, not counts. 

In order to show outcomes for distinct individual participants, a waffle plot comes in handy. These have become quite popular in data journalism to represent counts. 
Let's start with a waffle plot of 

```{r waffle}
indo_rct <- medicaldata::indo_rct
  scaler <- 1
indo_data <- indo_rct %>% group_by(outcome, rx) %>% count() %>%
  mutate(n = n/scaler)

indo_data %>% 
  #mutate(site = case_when(site == "1_UM" ~ "Michigan", site == "2_IU" ~ "Indiana", site == "3_UK" ~ "Kentucky", site == "4_Case" ~ "Case")) %>% 
  mutate(rx = str_sub(rx, 3L, 10L)) %>% 
  ggplot(aes(fill = outcome, values = n)) +
  geom_waffle(color = "white", size=0.25, n_rows = 10, 
              flip = TRUE, radius = unit(0.7, units = "mm")) +
  facet_wrap(~rx, nrow = 1, 
             strip.position = "bottom") +
  scale_x_discrete() + 
  scale_y_continuous(breaks = seq(10, 40, 10), 
      labels = function(x) format(x * 10*scaler, scientific = F),
              expand = c(0,0)) +
  scale_fill_manual(values = c("#1a85ff", "#d41159" )) +
  coord_equal() +
  labs(
    title = "Post-ERCP Outcomes by Treatment: <br><span style = 'color:#d41159;'>Pancreatitis</span>, or <span style = 'color:#1a85ff;'>No Event</span>, <br>in the Rectal Indomethacin Trial",
    subtitle = sprintf("One square = %s Outcome, Each Row = 10 Outcomes", scaler),
    x = "",
    y = "",
    caption = "Data: NEJM 2012; 366:1414-1422, Elmunzer"
  ) +
   theme_minimal() +
  #theme_ipsum_rc()+
  theme(panel.grid = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.ticks.y = element_line(),
        plot.title = element_markdown(),
        legend.position = "none") +
  guides(fill = guide_legend(reverse = TRUE))
```

The waffle plot is an interesting hack of ggplot. The geom_waffle() is actually a faceted plot, with one row of facets (examine the code above). You can change the scaler constant to make each square count for N cases. You can learn more about the many capabilities of the {waffle} package - including pictograms and an alternative to pie charts - [here](https://github.com/hrbrmstr/waffle).

Note that we have used colors in the title in place of a legend, by coloring the outcomes with the corresponding colors, using the {ggtext} extension package, which allows you to add color, backgrounds, images, bold face, or italic face to text in ggplots, using markdown/HTML tags. You can learn more about the many capabilities of the {ggtext} package and what it can do [here](https://github.com/wilkelab/ggtext).


## An Alluvial Plot

An alluvial plot depicts flow, like a river, which can split off branches and re-unite streams. This kind of plot can be helpful to show patient flow from one state to the next. This requires the {ggalluvial} package, which you may need to install and then load with the library() function.

The example below shows the flow of patients with chest pain from ED triage to hospitalization and an outcome of survived or died, stratified by gender.

```{r alluvial}
datafr <- tibble::tribble(
  ~gender, ~triage, ~next_day, ~outcome, ~count,
  "Male", "ER", "Hospitalized", "Survived", 211,
  "Male", "ER", "Hospitalized", "Survived", 43,
  "Male", "ER", "Discharged", "Died", 280,
  "Male", "ER", "Discharged", "Died", 15,
  "Male", "Observation", "Hospitalized", "Survived", 67,
  "Male", "Observation", "Hospitalized", "Died", 11,
  "Male", "Observation", "Discharged", "Survived", 415,
  "Male", "Observation", "Discharged", "Died", 5,
  "Female", "ER", "Hospitalized", "Survived", 219,
  "Female", "ER", "Hospitalized", "Survived", 33,
  "Female", "ER", "Discharged", "Died", 250,
  "Female", "ER", "Discharged", "Died", 45,
  "Female", "Observation", "Hospitalized", "Survived", 88,
  "Female", "Observation", "Hospitalized", "Died", 27,
  "Female", "Observation", "Discharged", "Survived", 402,
  "Female", "Observation", "Discharged", "Died", 14) %>% 
  mutate(gender = as_factor(gender),
         triage = as_factor(triage),
         next_day = as_factor(next_day),
         outcome = as_factor(outcome))

ggplot(datafr, 
       aes(y = count, axis1 = gender, axis2 = triage,
           axis3 = next_day)) +
  geom_alluvium(aes(fill = outcome), width = 1/12) +
  geom_stratum(width =1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("gender", "triage", "next_day"), expand = c(.10, .10)) +
  ggtitle("Patients Presenting with Chest Pain") +
  scale_fill_manual(values = c("#1a85ff", "#d41159" ))

```

:::tryit

Now try this yourself. Copy the code below (click on the copy icon in the top right of the code chunk), paste it into your RStudio IDE, and edit to:

- show the additive effects of ethanol use, cirrhosis, and HCC on death rates. Code the outcome as Survived or Died.

```{r alluvial1, error=TRUE}
datafr <- tibble::tribble(
  ~Ethanol_Use, ~Cirrhosis, ~HCC, ~outcome, ~count,
  "Yes", "Yes", "Yes", "Survived",  4,
  "Yes", "Yes", "Yes", "Died", 28,
  "Yes", "Yes", "No", "Survived", 12,
  "Yes", "Yes", "No", "Died", 45,
  "Yes", "No", "Yes", "Survived", 2,
  "Yes", "No", "Yes", "Died", 4,
  "Yes", "No", "No", "Survived", 57,
  "Yes", "No", "No", "Died", 26,
  "No", "Yes", "Yes", "Survived", 3,
  "No", "Yes", "Yes", "Died", 10,
  "No", "Yes", "No", "Survived", 32,
  "No", "Yes", "No", "Died", 26,
  "No", "No", "Yes", "Survived", 1,
  "No", "No", "Yes", "Died", 3,
  "No", "No", "No", "Survived", 297,
  "No", "No", "No", "Died", 15
  ) %>% 
  mutate(Ethanol_Use = as_factor(Ethanol_Use),
         Cirrhosis = as_factor(Cirrhosis),
         HCC = as_factor(HCC),
         outcome = as_factor(outcome))

ggplot(datafr, 
       aes(y = count, axis1 = ____, 
           axis2 = ____,
           axis3 = ____)) +
  geom_alluvium(aes(fill = outcome), width = 1/12) +
  geom_stratum(width =1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("____", "____", "____"), expand = c(.10, .10)) +
  ggtitle("Patients Presenting with Hepatitis C Infection") +
  scale_fill_manual(values = c("#1a85ff", "#d41159" ))
```

:::

`r hide('alluvial1-solution')`

```{r alluvial1-solution, warning=FALSE, message=FALSE}
datafr <- tibble::tribble(
  ~Ethanol_Use, ~Cirrhosis, ~HCC, ~outcome, ~count,
  "Yes", "Yes", "Yes", "Survived",  4,
  "Yes", "Yes", "Yes", "Died", 28,
  "Yes", "Yes", "No", "Survived", 12,
  "Yes", "Yes", "No", "Died", 45,
  "Yes", "No", "Yes", "Survived", 2,
  "Yes", "No", "Yes", "Died", 4,
  "Yes", "No", "No", "Survived", 57,
  "Yes", "No", "No", "Died", 26,
  "No", "Yes", "Yes", "Survived", 3,
  "No", "Yes", "Yes", "Died", 10,
  "No", "Yes", "No", "Survived", 32,
  "No", "Yes", "No", "Died", 26,
  "No", "No", "Yes", "Survived", 1,
  "No", "No", "Yes", "Died", 3,
  "No", "No", "No", "Survived", 297,
  "No", "No", "No", "Died", 15
  ) %>% 
  mutate(Ethanol_Use = as_factor(Ethanol_Use),
         Cirrhosis = as_factor(Cirrhosis),
         HCC = as_factor(HCC),
         outcome = as_factor(outcome))

ggplot(datafr, 
       aes(y = count, axis1 = Ethanol_Use, 
           axis2 = Cirrhosis,
           axis3 = HCC)) +
  geom_alluvium(aes(fill = outcome), width = 1/12) +
  geom_stratum(width =1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("Ethanol_Use", "Cirrhosis", "HCC"), expand = c(.10, .10)) +
  ggtitle("Patients Presenting with Hepatitis C Infection") +
  scale_fill_manual(values = c("#1a85ff", "#d41159" ))
```

`r unhide()`

:::tryit

Now try this again. Copy the code below (click on the copy icon in the top right of the code chunk), paste it into your RStudio IDE, and edit to:

- show the progression of inpatients through therapies for Acute Severe Ulcerative colitis through the first 90 days of therapy. Code the outcome as Intact or Colectomy.
- Use the examples above to build your alluvial plot

```{r alluvial2, error=TRUE, eval=FALSE}
datafr <- tibble::tribble(
  ~Day_1_Therapy, ~Day_7_Therapy, ~Day_28_Therapy, ~Day_90_Therapy, ~outcome, ~count,
  "IVCS + Upa", "Pred + Upa", "Upa", "Upa", "Intact", 19,
 "IVCS + Upa", "Pred + Upa", "Upa", NA, "Colectomy", 3,
  "IVCS + Upa", "Pred + Upa", NA, NA, "Colectomy", 4,
  "IVCS + Upa", "Cyclo", "Cyclo + IFX", "IFX", "Intact", 12,
  "IVCS + Upa", "IFX", "IFX + Aza", "IFX + Aza", "Intact", 9,
   "Upa", "Upa", "Upa", "Upa", "Intact", 12,
 "Upa", "Upa", "Upa", NA, "Colectomy", 5,
  "Upa", "Upa", NA, NA, "Colectomy", 7,
  "Upa", "Cyclo", "Cyclo + IFX", "IFX", "Intact", 9,
  "Upa", "IFX", "IFX + Aza", "IFX + Aza", "Intact", 7
  ) %>% 
  mutate(Day_1_Therapy = as_factor(Day_1_Therapy),
         Day_7_Therapy = as_factor(Day_7_Therapy),
         Day_28_Therapy = as_factor(Day_28_Therapy),
         Day_90_Therapy = as_factor(Day_90_Therapy),
         outcome = as_factor(outcome))
```
:::

`r hide('alluvial2-solution')`

```{r alluvial2-solution, warning=FALSE, message=FALSE}
datafr <- tibble::tribble(
  ~Day_1_Therapy, ~Day_7_Therapy, ~Day_28_Therapy, ~Day_90_Therapy, ~outcome, ~count,
  "IVCS + Upa", "Pred + Upa", "Upa", "Upa", "Intact", 19,
 "IVCS + Upa", "Pred + Upa", "Upa", NA, "Colectomy", 3,
  "IVCS + Upa", "Pred + Upa", NA, NA, "Colectomy", 4,
  "IVCS + Upa", "Cyclo", "Cyclo + IFX", "IFX", "Intact", 12,
  "IVCS + Upa", "IFX", "IFX + Aza", "IFX + Aza", "Intact", 9,
   "Upa", "Upa", "Upa", "Upa", "Intact", 12,
 "Upa", "Upa", "Upa", NA, "Colectomy", 5,
  "Upa", "Upa", NA, NA, "Colectomy", 7,
  "Upa", "Cyclo", "Cyclo + IFX", "IFX", "Intact", 9,
  "Upa", "IFX", "IFX + Aza", "IFX + Aza", "Intact", 7
  ) %>% 
  mutate(Day_1_Therapy = as_factor(Day_1_Therapy),
         Day_7_Therapy = as_factor(Day_7_Therapy),
         Day_28_Therapy = as_factor(Day_28_Therapy),
         Day_90_Therapy = as_factor(Day_90_Therapy),
         outcome = as_factor(outcome))

ggplot(datafr, 
       aes(y = count, axis1 = Day_1_Therapy, 
           axis2 = Day_7_Therapy,
           axis3 = Day_28_Therapy,
           axis4 = Day_90_Therapy)) +
  geom_alluvium(aes(fill = outcome), width = 1/12) +
  geom_stratum(width =1/12, fill = "black", color = "grey") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("Day_1_Rx", "Day_7_Rx", "Day_28_Rx", "Day_90_Rx"), expand = c(.18,0.1)) +
  ggtitle("Patients Presenting with Acute Severe UC") +
  scale_fill_manual(values = c("#1a85ff", "#d41159" )) 
```

`r unhide()`
## Lollipop Plots

While bar charts are quite popular for comparing continuous variables across categories, they have limitations. Humans are good at comparing length, but the bars add width, which is a distraction. Bar charts are also often used for counts, and it is not always clear whether a continuous or a discrete count variable is being plotted (a waffle chart can clear up discrete counts). For a continuous variable, you have a single point estimate (the end of the bar), and it is better to emphasize this estimate, without giving up the benefit of comparing lengths (which humans are good at). A lollipop plot emphasizes the continuous value, while de-emphasizing the width of a bar. Let's look at an example below.

```{r lollipop}
medicaldata::covid_testing %>% 
  mutate(positive = case_when(ct_result < 45 ~ 1,
                              ct_result >= 45 ~ 0)) %>% 
  group_by(demo_group) %>% 
  count(positive) %>% 
  filter(!is.na(positive)) %>% 
  mutate(freq = n/sum(n)) %>% 
  filter(positive==1) %>% 
  ggplot() +
  aes(x = fct_reorder(demo_group, freq), y = freq) + 
  geom_lollipop(point.size = 5, point.colour = "red") +
  scale_y_continuous(labels = scales::percent_format(scale = 100)) +
  labs(y = "Percent Positive", x = "Demographic Category")
```

:::tryit

Now try this yourself. Copy the code above (click on the copy icon in the top right of the code chunk), paste it into your RStudio IDE, and edit to:

- Change the x axis so that it starts at age 0, and ends at 85. 
- Make the x-axis expansion multiplier zero (not the default of 0.05). 

Click on the `Solution` button to toggle showing or hiding the solution.

`r hide('Solution')`
```{r scatter-3-solution}
indo_rct %>% 
  ggplot() +
  aes(x = age, y = risk, color = outcome) + 
  geom_jitter() +
  scale_y_continuous(limits = c(0,6)) +
  scale_x_continuous(limits = c(0,85),
          expand = expansion(mult = 0))
```

`r unhide()`
:::

## Dumbbell Plots

The Dumbbell Plot is a visualization that shows change between two points (usually 2 time points) in our data. It gets the name because of its dumbbell shape. It’s a great way to show changes in data between two points (think start and finish). 

Note that a bit of data wrangling needs to be done to produce the correct data format for geom_dumbbell(). You may need to pivot_wider() to get 2 columns of data on distinct dates (in this case, month 1 vs month 4). See the data wrangling below to get mean age for these 2 months.

```{r dumbbell}
medicaldata::covid_testing %>% 
  filter(!str_detect(patient_class, "surgery")) %>% 
  mutate(pan_month = ceiling((pan_day)/30)) %>% 
  filter(pan_month %in% c(1,4)) %>% 
  pivot_wider(names_from = pan_month,
              values_from = age,
              id_cols = patient_class,
    values_fn = function(x) mean(x, na.rm = TRUE),
              names_prefix = "month_") ->
dumb_covid_data
dumb_covid_data

dumb_covid_data %>% 
ggplot(aes(x = month_1, xend = month_4, y = patient_class,
           group = patient_class)) +
  geom_dumbbell(size = 2, # size of line
      size_x =4, size_xend = 4, # dot size
  colour = "lightblue2", #line color
  colour_x = "dodgerblue", # 1st dot color
  colour_xend = "blue") + # end dot color
  labs(x = "Mean Patient Age", y = "Patient Class",
       title = "Increases in Mean Patient Age at a Pediatric Hospital \nfrom Month 1 to Month 4 of the Pandemic",
       subtitle = "Keeping the Young Ones Safe at Home") +
  xlim(1,25) + # set limits on x axis
  theme_linedraw() +
  theme(plot.title.position = "plot") # align title and subtitle to left edge, rather than to plot area+

```



--



You can see that ggplot picks sensible breaks, but the defaults might not always work for you. Let's change the risk scale to breaks of 0.5, using the `breaks` argument. Note that using the `limits` argument also lets you establish the limits of the y-axis. 

```{r scatter-4}
indo_rct %>% 
  ggplot() +
  aes(x = age, y = risk, color = outcome) + 
  geom_point() +
  scale_y_continuous(limits = c(0,6),
                     breaks = seq(0, 6, by = 0.5)) 
```

:::tryit

Now try this yourself. Copy the code above (click on the copy icon in the top right of the code chunk), paste it into your RStudio IDE, and edit to:

- Change the x axis so that it starts at age 0, and ends at 95, with breaks at every decade from 10-90 (but not zero). 

Click on the `Solution` button to toggle showing or hiding the solution.

`r hide('Solution')`
```{r scatter-4-solution}
indo_rct %>% 
  ggplot() +
  aes(x = age, y = risk, color = outcome) + 
  geom_jitter() +
  scale_y_continuous(limits = c(0,6)) +
  scale_x_continuous(limits = c(0,95), 
                     expand = expansion(mult = 0),
                     breaks = seq(10, 90, by = 10))
```
Notice that the y axis has the default 5% multiplier, but the x axis does not, so it has limits exactly at 0 and 95.
`r unhide()`
:::


Let's expand the x axis to the right to make room for a legend in the plot on the right, using the `expand` argument. We can change the axis `name` and `position` as well.

```{r scatter-5b}
indo_rct %>% 
  ggplot() +
  aes(x = rx, y = risk, color = outcome) + 
  geom_jitter() +
  theme(legend.position = c(0.85, 0.5)) +
  scale_y_continuous(limits = c(0.5,6),
                     breaks = seq(0.5, 6, by = 0.5)) +
  scale_x_discrete(expand = expansion(add =c(0.6,1.5)),
                   name = "Treatment",
                   position = "top") 
```

:::tryit

Now try this yourself. Copy the code above (click on the copy icon in the top right of the code chunk), paste it into your RStudio IDE, and edit to:

- Change the x axis so that you 
- add 1.5 to the left side (add 1.5, 0.6), 
- move the legend to the left (0.15, 0.5)
- change the title to "Suppository"
- move the title position to the bottom

Click on the `Solution` button to toggle showing or hiding the solution.

`r hide('Solution')`
```{r scatter-5-solution}
indo_rct %>% 
  ggplot() +
  aes(x = rx, y = risk, color = outcome) + 
  geom_jitter() +
  theme(legend.position = c(0.15, 0.5)) +
  scale_y_continuous(limits = c(0.5,6),
                     breaks = seq(0.5, 6, by = 0.5)) +
  scale_x_discrete(expand = expansion(add =c(1.5, 0.6)),
                   name = "Suppository",
                   position = "bottom") 
```
The legend position is based on the proportion of the x axis (0-1) and the y axis (0-1), so that legend.position (0,0) is the bottom left, and legend.position (1,1) is the top right.
`r unhide()`
:::

--

## Test what you have learned

(correct answers will be green!)

- You can set the start and end points of an axis with the `limits` argument `r torf(TRUE)`

- You can set the ticks on an axis with the `r mcq(c(answer = 'breaks', 'ticks', 'lines'))` argument in a scales function.

- To expand the margin of a plot on one side by a specific amount, you use the `r mcq(c('mult', 'sqrt', answer = 'add'))` argument in the expand argument within a scales function.

## Spaghetti Plots with Summary Smoothed Lines for Change Over Time

The Spaghetti Plot is a visualization that shows change over multiple time points for longitudinal data, which lets you see change in each individual as a line. It gets the name because the result (with method = "lm") looks a bit like you scattered uncooked spaghetti (straight lines) on the plot. It’s a great way to show changes in data over multiple time points, and there are multiple variants, including summary smoothed lines. 

Note that a bit of data wrangling needs to be done to produce the correct data format for geom_line(). You may need to pivot_longer() to get 1 row of data for each data point, and an id for each individual (multiple points making up a line. This id will often be a patient id (pat_id). We will read in some simulated data below for 4 time points. The variables are time point, the value, ses (2 categories), elderly (2 categories), and pat_id for 8 patients.

The code below will illustrate the basic spaghetti plot.

```{r spaghetti, message=FALSE, warning=FALSE}

dat <- tibble::tribble(~time, ~value, ~ses, ~elderly, ~pat_id, 0,0,1,1,1, 1,3,1,1,1, 2,5,1,1,1, 3,8,1,1,1, 0,0,2,1,2, 1,4,2,1,2,  2,7,2,1,2, 3,9,2,1,2, 0,0,1,2,3, 1,5,1,2,3, 2,9,1,2,3, 3,11,1,2,3, 0,0,2,2,4, 1,5,2,2, 4, 2,9,2,2,4, 3,15,2,2,4, 0,0,1,1,5, 1,5,1,1,5, 2,6,1,1,5, 3,9,1,1,5, 0,0,2,1,6, 1,5,2,1,6,  2,8,2,1,6, 3,13,2,1,6, 0,0,1,2,7, 1,4,1,2,7, 2,8,1,2,7, 3,14,1,2,7, 0,0,2,2,8, 1,6,2,2,8, 2,8,2,2,8, 3,16,2,2,8)


ggplot(dat, aes(x = time, y = value, 
  group = factor(pat_id))) +
  geom_smooth(formula = y ~ x, se = FALSE, 
              method = "lm") +
  xlab("Observation Time Point") +
  ylab("Y") 
```

As you can see, a bit like spilled (uncooked) spaghetti, with a line for each patient. Each patient is the same (default) color. Note that it is **critical** to group y the patient id (group = factor(pat_id)) so that ggplot knows which points go together as a line. If you remove this bit of code for the group argument, you get chaos from *geom_smooth()* or *geom_line()*. We can also let each patient's line follow their actual values, rather than a fitted line, with a few modifications. Try this below.

```{r spaghetti2}
ggplot(dat, aes(x = time, y = value, 
  group = factor(pat_id))) +
  geom_point() +
  geom_line() +
  xlab("Observation Time Point") +
  ylab("Y") 
```
Now each patient is represented by a line (and points) with more detail than a fitted straight line.

We can also chose to color these lines in two classes by ses (SocioEconomic Status) by setting color = factor(ses). We can make the legend neater by putting it inside the plot boundaries with theme (legend.position), and use the x and y range from 0 to 1 to position it as below.

```{r spaghetti3}
ggplot(dat, aes(x = time, y = value, 
  group = factor(pat_id), color = factor(ses))) +
  geom_point() +
  geom_line() +
  theme(legend.position = c(0.8, 0.2)) + 
  xlab("Observation Time Point") +
  ylab("Y") 
```

If we want to summarize the overall pattern, we can use a *geom_smooth()* with the default loess smoothing. We set the color to "black", rather than the color of either SES group. We need to turn off the grouping with group = NULL to get a single summary line. Note the loess smoothing produces a curve.
```{r spaghetti4, warning=FALSE, message=FALSE}
ggplot(dat, aes(x = time, y = value, 
  group = factor(pat_id), color = factor(ses))) +
  geom_point() +
  geom_line() +
  theme(legend.position = c(0.8, 0.2)) + 
  xlab("Observation Time Point") +
  ylab("Y") +
  geom_smooth(formula = y ~ x, se=FALSE, size=2, method = "loess", color = "black", aes(group = NULL))
```

If we want to get fancy, we can also make summary curves for each ses group, and facet the plot by elderly status, as below.
```{r spaghetti5, warning=FALSE, message=FALSE}
elderly_labels <- c(
 `1` = "Young",
 `2` = "Old") 

ggplot(dat, aes(x = time, y = value, 
  group = factor(pat_id), color = factor(ses))) +
  geom_point() +
  geom_line() +
  theme(legend.position = c(0.8, 0.2)) + 
  xlab("Observation Time Point") +
  ylab("Y") +
  geom_smooth(se=FALSE, size=2, method = "loess",   aes(group = NULL, color = factor(ses))) +
  facet_grid(~elderly)
```

This gives us a plot faceted into two graphs, one for the elderly on the right, and the non-elderly on the left. Each individual is represented by points and a connected line. SES status is indicated by color, and a summary curve of each SES group is a thicker (size=1) loess curve.

:::tryit

Now try this yourself. Copy the code below (click on the copy icon in the top right of the code chunk), paste it into your RStudio IDE, and edit to: 
(Note you only have to read in the data (dat) once, just copy and edit the ggplot thereafter)

```{r}
dat <- tibble::tribble(~ patid, ~week, ~crp, ~fcp, ~flare, ~dz_type, 1,1,0.7,191,1,"uc", 1,3,1.1,302,1,"uc", 1,8,1.5,507,1,"uc", 
2,1,0.8,214,1,"cd", 2,3,1.2,412,1,"cd", 2,8,1.6,647,1,"cd",  
       3,1,0.7,137,0,"uc", 3,3,0.5,101,0,"uc", 3,8,0.4,58,0,"uc", 
      4,1,0.5,112,0,"cd", 4,3,0.3,81,0,"cd", 4,8,0.1,44,0,"cd",
      5,1,0.6,119,0,"uc", 5,3,0.4,87,0,"uc", 5,8,0.3,57,0,"uc", 
     6,1,0.7,216,0,"cd", 6,3,0.5,161,0,"cd", 6,8,0.3,92,0,"cd", 
       7,1,0.9,267,1,"uc", 7,3,1.1,412,1,"uc", 7,8,1.9,692,1,"uc",
  8,1,0.7,212,1,"cd",  8,3,1.1,342,1,"cd", 8,8,1.6,517,1,"cd", 
  9,1,0.9,197,0,"uc", 9,3,0.6,134,0,"uc", 9,8,0.4,86,0,"uc", 
10,1,0.5,143,0,"cd", 10,3,0.4,101,0,"cd", 10,8,0.3,64,0,"cd", 
11,1,0.7,217,0,"uc", 11,3,0.4,153,0,"uc", 11,8,0.3,51,0,"uc")


ggplot(dat, aes(x = week, y = crp, 
                group = factor(patid),
                color= factor(patid))) +
  geom_smooth(formula = y ~ x, se = FALSE, 
              method = "lm") +
  xlab("Week") +
  ylab("CRP") 
```


- (1) See the initial plot above for CRP with smooth lines for each patient, then try it for FCP.
- (2) Now plot the CRP values, and change the grouping to patid without colors, and use geom_point() and geom_line() rather than geom_smooth to see the CRP trends in black.
- (3) Now plot the CRP values, and add to the aes, color = factor(dz_type) OR color= factor(flare) to group = factor(patid)
- (4) Now plot the FCP values, and add the geom_smooth with group = NULL and color = factor(flare). Also facet_grid by dz_type, and see if you can improve the default legend title and labels (might need to google these).

Click on the `Solution` buttons below to toggle showing or hiding each solution.

:::

`r hide('Solution 1')`

```{r spaghetti-solution1, warning=FALSE, message=FALSE}

ggplot(dat, aes(x = week, y = crp, 
                group = factor(patid),
                color= factor(patid))) +
  geom_smooth(formula = y ~ x, se = FALSE, 
              method = "lm") +
  labs(x = "Week", y = "CRP", title = "CRP by week") +
  scale_x_continuous(breaks = c(1,3,8)) +
  expand_limits(x=0)

```

`r unhide()`

`r hide('Solution 2')`

```{r spaghetti-solution2, warning=FALSE, message=FALSE}

ggplot(dat, aes(x = week, y = crp, 
                group = factor(patid))) +
  geom_point() +
  geom_line() +
  labs(x = "Week", y = "CRP", title = "CRP by week") +
  scale_x_continuous(breaks = c(1,3,8)) +
  expand_limits(x=0)

```

`r unhide()`

`r hide('Solution 3')`

```{r spaghetti-solution3, warning=FALSE, message=FALSE}

ggplot(dat, aes(x = week, y = crp, 
      group = factor(patid),
      color = factor(flare))) +
  geom_point() +
  geom_line() +
  labs(x = "Week", y = "CRP", title = "CRP by week") +
  scale_x_continuous(breaks = c(1,3,8)) +
  expand_limits(x=0) +
  labs(color = "Flare")

```

`r unhide()`


`r hide('Solution 4')`

```{r spaghetti-solution4, warning=FALSE, message=FALSE}

ggplot(dat, aes(x = week, y = fcp, 
                group = factor(patid),
       color = factor(flare))) +
  geom_point() +
  geom_line() +
  labs(x = "Week", y = "FCP", title = "FCP by week") +
  scale_x_continuous(breaks = c(1,3,8)) +
  expand_limits(x=0) +
  geom_smooth(se=FALSE, size=2, method = "loess",   aes(group = NULL, color = factor(flare))) +
  facet_grid(~dz_type)  +
  labs(color = "Flare") +
  scale_color_discrete(breaks = c("1", "0"),
                      labels = c("Yes", "No"))
                      

```

`r unhide()`



## Direct Labeling of Plots

Whilea legend can help a viewer interpret a plot, it requires a bit of cognitive work to look back and forth between the plot and the legend to sort things out. If you have a manageable number of categories, it can be more effective to add category labels directly to your plot.

This can be done manually, with geom_label, or with a bit of help from {directlabel} or {geomtextpath}.


### GeomTextPath

This geom, from the {geomtextpath} package, allows you to put labels on a curved path, and can be helpful for labeling distributions.

In this density plot example, x will map to your continous variable/distribution, while color and label will map to your categorical variable. This is an example of age distributions by the type of sphincter of oddi dysfunction (the muscular valve at the end of the common discharge pathway of the bile ducts and pancreatic ducts into the small intestine) in the indo_rct dataset. The patients with more severe SOD tend to be younger than those without SOD, and type 2 SOD has a bimodal distribution.

```{r geomtextpath}
medicaldata::indo_rct %>% 
    ggplot(aes(x = age, colour = type)) +
    geom_textpath(aes(label = type), stat = "density",
    size = 4, fontface = 2, hjust = 0.65, vjust = -0.1) +
    theme(legend.position = "none")
```

:::tryit

Now try this yourself. Copy the code above (click on the copy icon in the top right of the code chunk), paste it into your RStudio IDE, and edit to:

- Change the legend 
- make the title "PEP" 
- change the labels to "good" and "BAD"
- change the colors to "yellow" and "darkorchid"

Click on the `Solution` button to toggle showing or hiding the solution.

`r hide('Solution')`
```{r scales-6-solution}
medicaldata::indo_rct %>% 
  ggplot() +
  aes(x = rx, y = risk, color = outcome) + 
  geom_jitter() +
  theme(legend.position = c(0.15, 0.5)) +
  scale_y_continuous(limits = c(0.5,6),
                     breaks = seq(0.5, 6, by = 0.5)) +
  scale_x_discrete(expand = expansion(add =c(1.5, 0.6)),
                   name = "Suppository",
                   position = "bottom")  + 
    scale_color_manual(name = "PEP", 
                        labels = c("good", "BAD"),
                        values = c("yellow", "darkorchid")) 
```
The legend position is based on the proportion of the x axis (0-1) and the y axis (0-1), so that legend.position (0,0) is the bottom left, and legend.position (1,1) is the top right.
`r unhide()`
:::

## Test what you have learned

(multiple-choice, fill-in-the-blank, and TRUE/FALSE - correct answers will be green!)

- You can take complete control of colors with `scale_color_` `r mcq(c('continuous', 'discrete', answer = 'manual'))`

- You can set the title of a color legend within the `scale_color_discrete()` function with the `r fitb('name')` argument.

- You can set the names of each level of a discrete color legend within the `scale_color_discrete()` function with the `r fitb('labels')` argument.

- You can set each color of a discrete color legend within the `scale_color_discrete()` function with the `values` `r torf(TRUE)` argument.

### More Examples with Flipbooks

<!---FLIPBOOK EX 2--> 

<iframe style="margin:0 auto; border: solid black;" 
id="myIframe12" width="763" height="432"
src="https://higgi13425.github.io/mini_flipbooks/scales2_microflip.html#1" 
scrolling="no" data-external="1" 
allowfullscreen
loading="lazy">
</iframe>

<!-------------> 


:::challenge

Now try some challenging code exercises using scales in the learnr app below.

Use your knowledge to try to do these without hints, but press the Hints button if needed. In each case, the 2nd hint is the solution.
:::
<!---SHINY APP--> 

<iframe style="margin:0 auto; border: solid black;" 
id="myIframe13" width="763" height="432"
src="https://higginslab-rshiny.med.umich.edu/shiny-apps/learn_scales/" 
scrolling="yes" data-external="1" 
allowfullscreen
loading="lazy">
</iframe>

<!-------------> 

